<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grammar Exercise: Modals</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Inter', 'Segoe UI', Tahoma, sans-serif;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      color: #2d3436;
      touch-action: manipulation;
    }

    .container {
      background-color: #ffffff;
      border-radius: 18px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
      width: 100%;
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      overflow-x: hidden;
      animation: fadeIn 0.5s ease-in-out;
    }

    header {
      background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      padding: 20px 28px;
      text-align: center;
    }

    h1 {
      font-size: 26px;
      margin-bottom: 5px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    header p {
      opacity: 0.95;
      font-size: 16px;
    }

    .instructions {
      background-color: #f8faff;
      padding: 15px 22px;
      border-bottom: 1px solid #e0e6f1;
      font-size: 15px;
      color: #555;
    }

    .exercise-container {
      padding: 20px 28px 28px;
    }

    .word-bank-container {
      margin: 15px 0;
    }

    .word-bank {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 12px;
      background-color: #f8faff;
      border-radius: 10px;
      border: 1px solid #e0e6f1;
      justify-content: center;
    }

    .word-item {
      padding: 8px 14px;
      background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      border-radius: 6px;
      cursor: grab;
      user-select: none;
      transition: transform 0.2s, box-shadow 0.2s;
      font-weight: 500;
      font-size: 14px;
      touch-action: none;
    }

    .word-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .word-item.dragging {
      opacity: 0.5;
    }

    .word-item.used {
      opacity: 0.5;
      background: linear-gradient(90deg, #cccccc 0%, #aaaaaa 100%);
      cursor: not-allowed;
    }

    .sentences {
      margin: 20px 0;
    }

    .sentence {
      margin-bottom: 15px;
      font-size: 17px;
      line-height: 1.6;
      padding: 10px;
      border-radius: 8px;
      background-color: #f9f9f9;
    }

    .gap {
      padding: 4px 8px;
      border-bottom: 2px dashed #4facfe;
      background-color: rgba(79, 172, 254, 0.12);
      border-radius: 4px;
      transition: background-color 0.25s, border-color 0.25s;
      display: inline-block;
      min-width: 120px;
      height: 32px;
      vertical-align: middle;
      cursor: pointer;
      position: relative;
    }

    .gap.active {
      background-color: rgba(79, 172, 254, 0.18);
      border-bottom-color: #1690ff;
      outline: 2px solid transparent;
    }

    .gap.filled {
      background-color: transparent;
      border-bottom: none;
      color: #3498db;
      font-weight: 600;
    }

    .gap.correct {
      color: #2ecc71;
    }

    .gap.incorrect {
      color: #e74c3c;
    }

    .progress-container {
      margin: 18px 0 20px;
    }

    .progress-bar {
      height: 10px;
      background-color: #f1f2f6;
      border-radius: 5px;
      overflow: hidden;
    }

    .progress {
      height: 100%;
      background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
      width: 0%;
      transition: width 0.5s ease;
    }

    .progress-text {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      color: #666;
      margin-top: 6px;
    }

    .message {
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 15px;
      text-align: center;
      font-weight: 600;
      display: none;
    }

    .success {
      background-color: #e8f9f1;
      color: #1f9e56;
      border: 1px solid #b8eacb;
    }

    .error {
      background-color: #fdecea;
      color: #d6453d;
      border: 1px solid #f5b7b1;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-top: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .controls button {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 700;
      transition: transform 0.15s, opacity 0.25s, background-color 0.25s;
      min-width: 140px;
      font-size: 14px;
    }

    .controls button:hover {
      transform: translateY(-1px);
      opacity: 0.95;
    }

    #check-btn {
      background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
      color: white;
    }

    #hint-btn {
      background-color: #f39c12;
      color: white;
    }

    #reset-btn {
      background-color: #e74c3c;
      color: white;
    }

    #solution-btn {
      background-color: #2ecc71;
      color: white;
    }

    footer {
      text-align: center;
      padding: 16px;
      color: #888;
      font-size: 14px;
      border-top: 1px solid #f1f2f6;
    }

    /* Mobile word selector */
    .mobile-word-selector {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      padding: 20px;
      box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
      z-index: 1000;
      max-height: 60vh;
      overflow-y: auto;
    }
    
    .mobile-word-selector h3 {
      margin-bottom: 15px;
      text-align: center;
      color: #4facfe;
    }
    
    .mobile-words-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    
    .mobile-word-option {
      padding: 12px;
      background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
      cursor: pointer;
    }
    
    .mobile-word-option.used {
      opacity: 0.5;
      background: #cccccc;
    }
    
    .close-selector {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
    }
    
    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 999;
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
        display: block;
        min-height: 100vh;
        height: auto;
      }
      
      .container {
        max-height: none;
        height: auto;
        overflow-y: visible;
        border-radius: 12px;
      }
      
      header {
        padding: 15px 20px;
      }
      
      h1 {
        font-size: 22px;
      }
      
      header p {
        font-size: 14px;
      }
      
      .instructions {
        padding: 12px 15px;
        font-size: 14px;
      }
      
      .exercise-container {
        padding: 15px 20px 20px;
      }
      
      .sentence {
        font-size: 16px;
        line-height: 1.5;
        margin-bottom: 20px;
      }
      
      .gap {
        min-width: 110px;
        display: block;
        margin: 8px 0;
        width: 100%;
        text-align: center;
      }
      
      .controls {
        flex-direction: column;
      }
      
      .controls button {
        width: 100%;
      }
      
      .word-bank-container {
        display: none;
      }
    }

    @media (max-width: 480px) {
      .mobile-words-grid {
        grid-template-columns: 1fr;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Focus styles for keyboard users */
    :focus-visible {
      outline: 3px solid rgba(79, 172, 254, 0.55);
      outline-offset: 2px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Grammar Exercise: Modals</h1>
      <p>should, must, have to</p>
    </header>

    <div class="instructions">
      <p>Complete the sentences. Drag and drop the correct words from the word bank.</p>
    </div>

    <div class="exercise-container">
      <div class="word-bank-container">
        <div class="word-bank" id="word-bank">
          <!-- Words will be populated by JavaScript in random order -->
        </div>
      </div>

      <div class="sentences">
        <div class="sentence">1 I think you <span class="gap" data-correct="should buy" data-id="1"></span> some suntan lotion for your trip.</div>
        <div class="sentence">2 You <span class="gap" data-correct="shouldn't drink" data-id="2"></span> a lot of coffee. It's bad for you.</div>
        <div class="sentence">3 Passengers <span class="gap" data-correct="must have" data-id="3"></span> tickets and passports.</div>
        <div class="sentence">4 You <span class="gap" data-correct="should speak" data-id="4"></span> to your boss if you have any questions.</div>
        <div class="sentence">5 In the U.S., you <span class="gap" data-correct="mustn't drive" data-id="5"></span> if you are under 16.</div>
        <div class="sentence">6 Students <span class="gap" data-correct="must answer" data-id="6"></span> all of the test questions.</div>
        <div class="sentence">7 You <span class="gap" data-correct="must go" data-id="7"></span> to your sister's wedding!</div>
        <div class="sentence">8 Rosita and Carlos <span class="gap" data-correct="should" data-id="8"></span> get married. They've been dating for four years!</div>
      </div>

      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress" id="progress-bar"></div>
        </div>
        <div class="progress-text">
          <span>Progress</span>
          <span id="progress-text">0%</span>
        </div>
      </div>

      <div class="message success" id="success-message">
        Congratulations! All answers are correct.
      </div>

      <div class="message error" id="error-message">
        Some answers are incorrect. Please try again.
      </div>

      <div class="controls">
        <button id="check-btn">Check answers</button>
        <button id="hint-btn">Hint</button>
        <button id="reset-btn">Reset</button>
        <button id="solution-btn">Show Solution</button>
      </div>
    </div>

    <footer>
      <p>Grammar Exercise &copy; 2023</p>
    </footer>
  </div>

  <!-- Mobile word selector (hidden by default) -->
  <div class="overlay" id="overlay"></div>
  <div class="mobile-word-selector" id="mobile-word-selector">
    <button class="close-selector" id="close-selector">Ã—</button>
    <h3>Select a phrase</h3>
    <div class="mobile-words-grid" id="mobile-words-grid">
      <!-- Will be populated by JavaScript -->
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Define the words for the exercise based on the screenshot
      const words = [
        "should buy",
        "must go",
        "must have",
        "must answer",
        "should",
        "should speak",
        "mustn't drive",
        "shouldn't drink"
      ];
      
      // Check if we're on a mobile device
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      
      // Shuffle the words array to randomize order
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }
      
      // Initialize word bank with shuffled words
      const wordBank = document.getElementById('word-bank');
      const shuffledWords = shuffleArray([...words]);
      
      shuffledWords.forEach(word => {
        const wordItem = document.createElement('div');
        wordItem.className = 'word-item';
        wordItem.setAttribute('draggable', 'true');
        wordItem.dataset.word = word;
        wordItem.textContent = word;
        wordBank.appendChild(wordItem);
      });
      
      // Get DOM elements
      const gaps = document.querySelectorAll('.gap');
      const wordItems = document.querySelectorAll('.word-item');
      const progressBar = document.getElementById('progress-bar');
      const progressText = document.getElementById('progress-text');
      const successMessage = document.getElementById('success-message');
      const errorMessage = document.getElementById('error-message');
      const checkBtn = document.getElementById('check-btn');
      const hintBtn = document.getElementById('hint-btn');
      const resetBtn = document.getElementById('reset-btn');
      const solutionBtn = document.getElementById('solution-btn');
      
      // Mobile elements
      const mobileWordSelector = document.getElementById('mobile-word-selector');
      const mobileWordsGrid = document.getElementById('mobile-words-grid');
      const closeSelector = document.getElementById('close-selector');
      const overlay = document.getElementById('overlay');
      
      let filledGaps = 0;
      const totalGaps = gaps.length;
      let hasCheckedAnswers = false;
      let activeGap = null;
      
      // Initialize progress
      updateProgress();
      
      // Initialize mobile word selector if on mobile
      if (isMobile) {
        initMobileWordSelector();
      }
      
      // Initialize drag and drop functionality for desktop
      if (!isMobile) {
        initDragAndDrop();
      }
      
      function initMobileWordSelector() {
        // Hide the desktop word bank on mobile
        document.querySelector('.word-bank-container').style.display = 'none';
        
        // Populate mobile word selector
        shuffledWords.forEach(word => {
          const wordOption = document.createElement('div');
          wordOption.className = 'mobile-word-option';
          wordOption.dataset.word = word;
          wordOption.textContent = word;
          wordOption.addEventListener('click', function() {
            if (!this.classList.contains('used')) {
              fillGap(activeGap, this.dataset.word);
              closeWordSelector();
            }
          });
          mobileWordsGrid.appendChild(wordOption);
        });
        
        // Add click event to gaps for mobile
        gaps.forEach(gap => {
          gap.addEventListener('click', function() {
            if (!this.classList.contains('filled')) {
              activeGap = this;
              showWordSelector();
            } else {
              freeGap(this);
            }
          });
        });
        
        // Close selector events
        closeSelector.addEventListener('click', closeWordSelector);
        overlay.addEventListener('click', closeWordSelector);
      }
      
      function showWordSelector() {
        mobileWordSelector.style.display = 'block';
        overlay.style.display = 'block';
        document.body.style.overflow = 'hidden';
      }
      
      function closeWordSelector() {
        mobileWordSelector.style.display = 'none';
        overlay.style.display = 'none';
        document.body.style.overflow = 'auto';
        activeGap = null;
      }
      
      // Initialize drag and drop functionality
      function initDragAndDrop() {
        // Add event listeners to word items for drag start
        wordItems.forEach(word => {
          word.addEventListener('dragstart', handleDragStart);
          word.addEventListener('dragend', handleDragEnd);
        });
        
        // Add event listeners to gaps for drag events
        gaps.forEach(gap => {
          gap.addEventListener('dragover', handleDragOver);
          gap.addEventListener('dragenter', handleDragEnter);
          gap.addEventListener('dragleave', handleDragLeave);
          gap.addEventListener('drop', handleDrop);
          gap.addEventListener('click', handleGapClick);
        });
      }
      
      // Handle drag start
      function handleDragStart(e) {
        this.classList.add('dragging');
        e.dataTransfer.setData('text/plain', this.dataset.word);
      }
      
      // Handle drag end
      function handleDragEnd() {
        this.classList.remove('dragging');
      }
      
      // Handle gap click - to free a completed gap
      function handleGapClick(e) {
        // Only allow freeing gaps if they're filled
        if (this.classList.contains('filled')) {
          freeGap(this);
        }
      }
      
      // Free a gap (remove the answer)
      function freeGap(gap) {
        const word = gap.textContent;
        gap.textContent = '';
        gap.classList.remove('filled', 'correct', 'incorrect');
        
        // Make the word available again
        if (isMobile) {
          document.querySelectorAll('.mobile-word-option').forEach(option => {
            if (option.dataset.word === word) {
              option.classList.remove('used');
            }
          });
        } else {
          wordItems.forEach(wordItem => {
            if (wordItem.dataset.word === word) {
              wordItem.classList.remove('used');
            }
          });
        }
        
        filledGaps--;
        updateProgress();
        
        // Hide messages when user makes changes
        successMessage.style.display = 'none';
        errorMessage.style.display = 'none';
        hasCheckedAnswers = false;
      }
      
      // Handle drag over
      function handleDragOver(e) {
        e.preventDefault();
      }
      
      // Handle drag enter
      function handleDragEnter(e) {
        e.preventDefault();
        this.classList.add('active');
      }
      
      // Handle drag leave
      function handleDragLeave() {
        this.classList.remove('active');
      }
      
      // Handle drop
      function handleDrop(e) {
        e.preventDefault();
        this.classList.remove('active');
        
        const word = e.dataTransfer.getData('text/plain');
        
        // If this gap is already filled, free it first
        if (this.classList.contains('filled')) {
          freeGap(this);
        }
        
        fillGap(this, word);
      }
      
      // Fill gap with word
      function fillGap(gap, word) {
        // Fill the gap
        gap.textContent = word;
        gap.classList.add('filled');
        filledGaps++;
        
        // Mark word as used
        if (isMobile) {
          document.querySelectorAll('.mobile-word-option').forEach(option => {
            if (option.dataset.word === word) {
              option.classList.add('used');
            }
          });
        } else {
          wordItems.forEach(wordItem => {
            if (wordItem.dataset.word === word) {
              wordItem.classList.add('used');
            }
          });
        }
        
        // Update progress
        updateProgress();
        
        // If we've previously checked answers, reset the visual state for new answers
        if (hasCheckedAnswers) {
          gap.classList.remove('correct', 'incorrect');
        }
        
        // Hide messages when user makes changes
        successMessage.style.display = 'none';
        errorMessage.style.display = 'none';
        hasCheckedAnswers = false;
        
        // Check if all gaps are filled
        if (filledGaps === totalGaps) {
          // Auto-check if all gaps are filled
          checkAnswers();
        }
      }
      
      // Update progress bar and text
      function updateProgress() {
        const progress = (filledGaps / totalGaps) * 100;
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${Math.round(progress)}%`;
      }
      
      // Check answers
      function checkAnswers() {
        let allCorrect = true;
        
        gaps.forEach(gap => {
          const userAnswer = gap.textContent.trim().toLowerCase();
          const correctAnswer = gap.dataset.correct.toLowerCase();
          
          if (userAnswer !== correctAnswer) {
            gap.classList.add('incorrect');
            gap.classList.remove('correct');
            allCorrect = false;
          } else {
            gap.classList.add('correct');
            gap.classList.remove('incorrect');
          }
        });
        
        if (allCorrect) {
          successMessage.style.display = 'block';
          errorMessage.style.display = 'none';
        } else {
          successMessage.style.display = 'none';
          errorMessage.style.display = 'block';
        }
        
        hasCheckedAnswers = true;
      }
      
      // Handle check button click
      checkBtn.addEventListener('click', checkAnswers);
      
      // Handle hint button click
      hintBtn.addEventListener('click', function() {
        // Find first unfilled gap or incorrect answer
        let gapToHint = null;
        
        for (const gap of gaps) {
          if (!gap.classList.contains('filled')) {
            gapToHint = gap;
            break;
          } else if (gap.textContent.trim().toLowerCase() !== gap.dataset.correct.toLowerCase()) {
            gapToHint = gap;
            break;
          }
        }
        
        if (gapToHint) {
          // Highlight the gap
          gapToHint.classList.add('active');
          
          // Show first letter as hint
          const correctAnswer = gapToHint.dataset.correct;
          alert(`Hint: The correct phrase is "${correctAnswer}".`);
          
          // Remove highlight after a delay
          setTimeout(() => {
            gapToHint.classList.remove('active');
          }, 2000);
        } else {
          alert('All gaps are correctly filled!');
        }
      });
      
      // Handle reset button click
      resetBtn.addEventListener('click', function() {
        gaps.forEach(gap => {
          const word = gap.textContent;
          gap.textContent = '';
          gap.classList.remove('filled', 'correct', 'incorrect');
          
          // Make the word available again
          if (isMobile) {
            document.querySelectorAll('.mobile-word-option').forEach(option => {
              if (option.dataset.word === word) {
                option.classList.remove('used');
              }
            });
          } else {
            wordItems.forEach(wordItem => {
              if (wordItem.dataset.word === word) {
                wordItem.classList.remove('used');
              }
            });
          }
        });
        
        filledGaps = 0;
        updateProgress();
        successMessage.style.display = 'none';
        errorMessage.style.display = 'none';
        hasCheckedAnswers = false;
      });
      
      // Handle solution button click
      solutionBtn.addEventListener('click', function() {
        gaps.forEach(gap => {
          gap.textContent = gap.dataset.correct;
          gap.classList.add('filled', 'correct');
          gap.classList.remove('incorrect');
          
          // Mark words as used
          if (isMobile) {
            document.querySelectorAll('.mobile-word-option').forEach(option => {
              if (option.dataset.word === gap.dataset.correct) {
                option.classList.add('used');
              }
            });
          } else {
            wordItems.forEach(wordItem => {
              if (wordItem.dataset.word === gap.dataset.correct) {
                wordItem.classList.add('used');
              }
            });
          }
        });
        
        filledGaps = totalGaps;
        updateProgress();
        checkAnswers();
      });
      
      // Initialize the exercise
      if (!isMobile) {
        initDragAndDrop();
      }

      // ---- Improved Drag Scrolling for Desktop ----
      const scrollContainer = document.querySelector('.container');
      const SCROLL_SPEED = 25;
      const SCROLL_ZONE = 80;

      document.addEventListener('dragover', function(e) {
        if (!scrollContainer || isMobile) return;
        const rect = scrollContainer.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const height = scrollContainer.clientHeight;

        if (y < SCROLL_ZONE) {
          scrollContainer.scrollTop -= SCROLL_SPEED;
        } else if (y > height - SCROLL_ZONE) {
          scrollContainer.scrollTop += SCROLL_SPEED;
        }
      });
    });
  </script>
</body>
</html>
